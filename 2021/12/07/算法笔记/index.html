<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="John Doe" />
  <meta name="description" content="" />
  
  
  <title>
    
      算法笔记 
      
      
      |
    
     Hexo
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">算法笔记</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-12-07 23:58:51
        </span>
        
      </div>
      <div class="markdown-body">
        <h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="Java-IO-流模板"><a href="#Java-IO-流模板" class="headerlink" title="Java IO 流模板"></a>Java IO 流模板</h2><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> BufferedWriter out=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one=Integer.parseInt(in.readLine());<span class="comment">//单字符输入</span></span><br><span class="line">        String[] s1=reder.readLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//多字符用字符数组接收再转类型</span></span><br><span class="line">        <span class="keyword">int</span> n=Integer.parseInt(s1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m=Integer.parseInt(s1[<span class="number">1</span>]);</span><br><span class="line">        String s=in.readLine();<span class="comment">//字符串输入</span></span><br><span class="line">        out.write();<span class="comment">//打印输出</span></span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        StreamTokenizer in=<span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        PrintWriter out=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">while</span>(in.nextToken()!=StreamTokenizer.TT_EOF)&#123;<span class="comment">//文件结束不再接收</span></span><br><span class="line">            <span class="keyword">int</span> n=(<span class="keyword">int</span>) in.nval;</span><br><span class="line">            in.nextToken();<span class="comment">//每次输入后必需写，让其向后读取直到eof</span></span><br><span class="line">            String s1=in.sval;<span class="comment">//只能接收纯字母，其它接收失败</span></span><br><span class="line">            in.nextToken();</span><br><span class="line">            out.println(n);<span class="comment">//打印输出</span></span><br><span class="line">           	out.flush();</span><br><span class="line">          	out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=arr[left+right&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=left-<span class="number">1</span>,r=right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++l]&lt;mid);</span><br><span class="line">        <span class="keyword">while</span>(arr[--r]&gt;mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)swap(arr[l],arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">        quick_sort(left,r);</span><br><span class="line">        quick_sort(r+<span class="number">1</span>,right);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-第K个数"><a href="#2-第K个数" class="headerlink" title="2.第K个数"></a>2.第K个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>],k;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quick_k</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> arr[left];</span><br><span class="line">    <span class="keyword">int</span> mid=arr[left+right&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=left-<span class="number">1</span>,r=right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++l]&lt;mid);</span><br><span class="line">        <span class="keyword">while</span>(arr[--r]&gt;mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)swap(arr[l],arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=r-k+<span class="number">1</span>;<span class="comment">//利用快排分治，只需确定第k个数所在区间</span></span><br><span class="line">    <span class="keyword">if</span>(flag&gt;=<span class="number">0</span>)<span class="keyword">return</span> quick_k(left,r);<span class="comment">//k在左区间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_k(r+<span class="number">1</span>,right); <span class="comment">//在右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];<span class="comment">//开多一个临时数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meger_sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先分后治</span></span><br><span class="line">    meger_sort(left,mid);</span><br><span class="line">    meger_sort(mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">int</span> l=left,r=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=right) temp[k++]=arr[l]&lt;=arr[r]?arr[l++]:arr[r++];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid) temp[k++]=arr[l++];</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=right) temp[k++]=arr[r++];</span><br><span class="line">    <span class="keyword">for</span>(l=left,k=<span class="number">0</span>;l&lt;=right;l++,k++) arr[l]=temp[k]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-逆序对的数量"><a href="#4-逆序对的数量" class="headerlink" title="4.逆序对的数量"></a>4.逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span>   <span class="number">10</span>  <span class="number">12</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">3</span>   <span class="number">10</span>  <span class="number">12</span> </span><br><span class="line"><span class="number">4</span> 和 <span class="number">5</span> 为逆序对，也分别和 <span class="number">3</span> 互为逆序对</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meger_ans</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       meger_ans(left,mid);</span><br><span class="line">       meger_ans(mid+<span class="number">1</span>,right);</span><br><span class="line">       <span class="keyword">int</span> l=left,r=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=right)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[l]&lt;=arr[r])</span><br><span class="line">               temp[k++]=arr[l++];</span><br><span class="line">           <span class="keyword">else</span>&#123;<span class="comment">//ans记录逆序对的数量</span></span><br><span class="line">               ans+=mid-l+<span class="number">1</span>;</span><br><span class="line">               temp[k++]=arr[r++]; </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(l&lt;=mid)temp[k++]=arr[l++];</span><br><span class="line">       <span class="keyword">while</span>(r&lt;=right)temp[k++]=arr[r++];</span><br><span class="line">       <span class="keyword">for</span>(l=left,k=<span class="number">0</span>;l&lt;=right;l++,k++)arr[l]=temp[k];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-二分"><a href="#5-二分" class="headerlink" title="5.二分"></a>5.二分</h3><h4 id="数的范围-整数二分"><a href="#数的范围-整数二分" class="headerlink" title="数的范围  整数二分"></a>数的范围  整数二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左区间</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;=k) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]!=k)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>+<span class="string">&quot; &quot;</span>+-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.print(left+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            right=n-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右区间</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=left+right+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid]&lt;=k) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(left);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="三次方根-小数二分"><a href="#三次方根-小数二分" class="headerlink" title="三次方根  小数二分"></a>三次方根  小数二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> left=-<span class="number">10000</span>,right=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(res*res*res-n&gt;<span class="number">1e-8</span>||n-res*res*res&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">	res=(left+right)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(res*res*res&gt;n) right=res;</span><br><span class="line">	<span class="keyword">else</span> left=res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.6f&quot;</span>+<span class="string">&quot;\n&quot;</span>,res);</span><br></pre></td></tr></table></figure>

<h3 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6.前缀和"></a>6.前缀和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	arr[i]+=arr[i-<span class="number">1</span>];</span><br><span class="line">res=arr[r]-arr[l-<span class="number">1</span>];</span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		arr[i][j]+=arr[i][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		arr[i][j]+=arr[i-<span class="number">1</span>][j];</span><br><span class="line">res=arr[x2][y2]+arr[x1-<span class="number">1</span>][y1-<span class="number">1</span>]-arr[x1-<span class="number">1</span>][y2]-arr[x2][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="7-差分"><a href="#7-差分" class="headerlink" title="7.差分"></a>7.差分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ggs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	temp[l]+=c;</span><br><span class="line">	temp[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维差分</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ggs</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	temp[x1][y1]+=c;</span><br><span class="line">    temp[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    temp[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    temp[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-双指针"><a href="#8-双指针" class="headerlink" title="8.双指针"></a>8.双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//i指针</span></span><br><span class="line">	temp[arr[i]]++;</span><br><span class="line">	<span class="keyword">while</span>(temp[arr[i]]&gt;<span class="number">1</span>)&#123;<span class="comment">//判断j指针条件</span></span><br><span class="line">		temp[arr[j]]--;</span><br><span class="line"> 		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(max&lt;i-j+<span class="number">1</span>)&#123;<span class="comment">//条件达成</span></span><br><span class="line">		max=i-j+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取二进制下k位置的数</span></span><br><span class="line">	（n&gt;&gt;k）&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;-x;<span class="comment">//x&amp;(~x+1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10.离散化"></a>10.离散化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] t,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//获取排名，从开始</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=t.length;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t[mid]&gt;=x) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//排序去重</span></span><br><span class="line">        SortedSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//set可以去重并从小到大排序</span></span><br><span class="line">            set.add(x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        flag=set.size();</span><br><span class="line">        <span class="keyword">int</span> t[]=<span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> te=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur:set)&#123;<span class="comment">//把集合处理好的数放入一个临时数组中</span></span><br><span class="line">            t[te++]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp[i]=lower_bound(t,x[i])+<span class="number">1</span>;<span class="comment">//存储离散化后的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11.区间合并"></a>11.区间合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思想：从小到大排列区间头部，依次判断右边界</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>全部用数组模拟</p>
<h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne=<span class="keyword">new</span> <span class="keyword">int</span>[N],head,idx;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    head=-<span class="number">1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在头部添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    en[idx]=head;</span><br><span class="line">    head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在k后添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    en[idx]=en[k];</span><br><span class="line">    en[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> K)</span></span>&#123;<span class="comment">//删除k后的数</span></span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],l[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],r[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在k后加添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[r[k]]=idx;<span class="comment">//不可颠倒</span></span><br><span class="line">    r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//删除k</span></span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],tt;</span><br><span class="line"><span class="comment">//添加push</span></span><br><span class="line">q[++t]=x;</span><br><span class="line"><span class="comment">//弹出pop</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//查看栈是否为空empoty</span></span><br><span class="line"><span class="keyword">boolean</span> flag=tt&lt;=<span class="number">0</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],hh,tt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tt=-<span class="number">1</span>;</span><br><span class="line">    hh=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加push</span></span><br><span class="line">qq[++tt]=x;</span><br><span class="line"><span class="comment">//弹出pop</span></span><br><span class="line">hh++;</span><br><span class="line"><span class="comment">//查看对头元素</span></span><br><span class="line">q[hh];</span><br><span class="line"><span class="comment">//查看队列是否为空</span></span><br><span class="line"><span class="keyword">boolean</span> flag=hh&gt;=tt?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-单调栈"><a href="#5-单调栈" class="headerlink" title="5.单调栈"></a>5.单调栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],tt,temp;</span><br><span class="line"><span class="keyword">while</span>(tt&gt;<span class="number">0</span>&amp;&amp;q[tt]&gt;=temp)<span class="comment">//单调递增</span></span><br><span class="line">tt--;<span class="comment">//弹出所有大于temp的数</span></span><br><span class="line">q[++tt]=temp;<span class="comment">//保留temp,最后形成一个单调递增的栈</span></span><br></pre></td></tr></table></figure>

<h3 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6.单调队列"></a>6.单调队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],hh,tt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hh=<span class="number">0</span>;</span><br><span class="line">    tt=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找最小值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 判断队头是否已经滑出窗口, 如果滑出窗口, 则弹出队首元素,维护窗口大小不超过 k, 每次值滑动一次, 所以可以使用 if</span></span><br><span class="line">	<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])</span><br><span class="line">		hh++;</span><br><span class="line">    <span class="comment">// 寻找窗口中的最小值</span></span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &gt;= arr[i]) </span><br><span class="line">		tt--;</span><br><span class="line">	q[++tt] = i;    <span class="comment">// 将本轮下标添加到队列中</span></span><br><span class="line">    <span class="comment">// 保证满足窗口大小, 比如窗口大小为 3, 不能此时只进入 2个数字</span></span><br><span class="line">	<span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) log.write(arr[q[hh]] + <span class="string">&quot; &quot;</span>);    <span class="comment">// 窗口内的最小值为队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-kmp"><a href="#7-kmp" class="headerlink" title="7.kmp"></a>7.kmp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> next[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">next[<span class="number">0</span>]=-<span class="number">1</span>;<span class="comment">//java从0开始，要初始化next[0]=-1；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=-<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//next数组生成</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;-<span class="number">1</span>&amp;&amp;p.charAt(i)!=p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.charAt(i)==p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=-<span class="number">1</span>;i&lt;m,i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;-<span class="number">1</span>&amp;&amp;s.charAt(i)!=p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i)==p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==n-<span class="number">1</span>)&#123;</span><br><span class="line">        out.print(i-n+<span class="number">1</span>+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-Trie字符串统计"><a href="#8-Trie字符串统计" class="headerlink" title="8.Trie字符串统计"></a>8.Trie字符串统计</h3><p>把字符存在一棵树中，用一个二维数组模拟树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> son[][]=<span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>],cnt[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;<span class="comment">//idx表示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Sting str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str.charAt(i)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//把字母映射到下标；0-25;</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>)&#123;<span class="comment">//如果当前没有存有，则标记</span></span><br><span class="line">            son[p][u]=++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//结束标记以此为下标的数的总数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str.cahAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>)&#123;<span class="comment">//从头查找，没有直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//当前找到则向下查找</span></span><br><span class="line">            p=son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];<span class="comment">//循环结束则说明有这个数返回数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9.并查集"></a>9.并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> p[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)p=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)&#123;<span class="comment">//如果本身不是头节点</span></span><br><span class="line">        <span class="comment">//继续向上寻找头节点，直到找到为止；并把当前节点指向头节点</span></span><br><span class="line">        p[x]=find(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];<span class="comment">//最后返回头节点        </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询a,b是否在同一集合</span></span><br><span class="line">find(a)==find(b)</span><br><span class="line"><span class="comment">//把a,b所在集合合并</span></span><br><span class="line">p[find(a)]=find(b);<span class="comment">//把a所在集合指向b的头节点</span></span><br><span class="line"><span class="comment">//可以用额外数组维护同一集合的数量</span></span><br><span class="line"><span class="keyword">int</span> size[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)size[i]=<span class="number">1</span>;</span><br><span class="line">size[find(b)]+=size[find(a)]</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h3 id="10-堆"><a href="#10-堆" class="headerlink" title="10.堆"></a>10.堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> heap[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],size;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//向下找最小值</span></span><br><span class="line">    <span class="keyword">int</span> u=x;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&gt;size&amp;&amp;heap[x]&gt;heap[u*<span class="number">2</span>])x=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&gt;size&amp;&amp;heap[x]&gt;heap[u*<span class="number">2</span>+<span class="number">1</span>])x=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=u)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=heap[x];</span><br><span class="line">        heap[x]=heap[u];</span><br><span class="line">        heap[u]=temp;</span><br><span class="line">        down(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//向上找更大值</span></span><br><span class="line">    <span class="keyword">if</span>(u/<span class="number">2</span>&amp;&amp;heap[u]&lt;heap[u/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=heap[u];</span><br><span class="line">        heap[u]=heap[u/<span class="number">2</span>];</span><br><span class="line">        heap[u]=temp;</span><br><span class="line">        up(u/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">size=n;<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)down(i);<span class="comment">//快速建堆</span></span><br><span class="line"><span class="comment">//删除最小值</span></span><br><span class="line">heap[<span class="number">1</span>]=heap[size--];<span class="comment">//用最后一个数覆盖第一个数，并删除最后一个数</span></span><br><span class="line">down(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除任意值</span></span><br><span class="line">heap[k]=heap[size--];</span><br><span class="line">down(k);</span><br><span class="line">up(k);</span><br><span class="line"><span class="comment">//修改任意值</span></span><br><span class="line">heap[k]=x;down(k);up(k);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-哈希表"><a href="#11-哈希表" class="headerlink" title="11.哈希表"></a>11.哈希表</h3><p>我的理解：哈希函数就是对一个质数取模，且保证他们的映射在范围之内</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">static</span> heap[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line">Arrays.fill(heap,-<span class="number">1</span>);<span class="comment">//初始化heap，全部指向-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=heap[k];</span><br><span class="line">    heap[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=heap[k];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line">   <span class="keyword">static</span> Integer h[]=<span class="keyword">new</span> Integer[<span class="number">2</span>*N];<span class="comment">//开多倍数组</span></span><br><span class="line">Arrays.fill(h,<span class="keyword">null</span>);<span class="comment">//初始化为null,int 办不到所以要Integer</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">       <span class="keyword">while</span>(h[k]!=<span class="keyword">null</span>&amp;&amp;h[k]!=x)&#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       h[k]=x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">       <span class="keyword">while</span>(h[k]!=<span class="keyword">null</span>&amp;&amp;h[k]!=x)&#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(h[k]==<span class="keyword">null</span>)&#123;<span class="comment">//不能用h[k]==x作为判断条件，暂时不知道为什么</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>字符串前缀哈希法</p>
<p>预处理所有前缀的哈希，用到前缀和所以要从1开始，字母不能映射为0，理想状态下不存在冲突；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> P=<span class="number">131</span>;<span class="comment">//p取131或13331避免冲突，</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> h[]=<span class="keyword">new</span> <span class="keyword">long</span>[N],p[]=<span class="keyword">new</span> <span class="keyword">long</span>[N];<span class="comment">//h[]存哈希后的前缀和，p[]存预处理p的n次方，mod取2^64^,java中long超程就是对mod取模</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> str[]=<span class="keyword">new</span> <span class="keyword">char</span>[N];<span class="comment">//存字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//求一个区间内的哈希值</span></span><br><span class="line">    <span class="keyword">long</span> res=h[r]-h[l-<span class="number">1</span>]*p[r-l+<span class="number">1</span>];<span class="comment">//由高位到低位存储，最低位下标实际上就是最高位的上标</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner cin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=cin.nextInt();</span><br><span class="line">    <span class="keyword">int</span> m=cin.nextInt();</span><br><span class="line">    String s=cin.next();</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">        str[i]=s.charAt(i-<span class="number">1</span>);</span><br><span class="line">        p[i]=p[i-<span class="number">1</span>]*P;<span class="comment">//预处理</span></span><br><span class="line">        h[i]=h[i-<span class="number">1</span>]*P+str[i];<span class="comment">//前缀和</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="搜索和图论"><a href="#搜索和图论" class="headerlink" title="搜索和图论"></a>搜索和图论</h2><h3 id="1-深度优先搜索-DFS"><a href="#1-深度优先搜索-DFS" class="headerlink" title="1.深度优先搜索 DFS"></a>1.深度优先搜索 DFS</h3><p>暴力搜索所有结果，递归回溯要还原现场</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  p[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],n;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> s[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,i&lt;=n;i++)&#123;<span class="comment">//相关操作</span></span><br><span class="line">            System.out.print(p[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s[j])&#123;</span><br><span class="line">        	p[j]=i;</span><br><span class="line">            s[j]=<span class="keyword">true</span>;<span class="comment">//标记</span></span><br><span class="line">            dfs(u+<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">            s[j]=<span class="keyword">false</span>;<span class="comment">//还原现场</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-宽度优先搜索BFS"><a href="#2-宽度优先搜索BFS" class="headerlink" title="2.宽度优先搜索BFS"></a>2.宽度优先搜索BFS</h3><p>当权值一样时有最短路概念，即优先搜索相同距离，并向外扩散，直到所有结果出现</p>
<p>道理都懂，代码不会实现…..</p>
<p>手写队列和内部队列速度差不多，代码繁琐其实不难</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部数据结构queue,事实证明对于java内部队列和手写队列速度差不了多少</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;<span class="comment">//定义点类</span></span><br><span class="line">        <span class="keyword">int</span> x, y, step;<span class="comment">//存坐标和步数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.step = step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;Point&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//定义队列</span></span><br><span class="line">    <span class="comment">//add添加，isEmpty是否为空,poll弹出</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] mx = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] my = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//x,y入队</span></span><br><span class="line">        flag[<span class="number">1</span>][<span class="number">1</span>]=<span class="keyword">true</span>;<span class="comment">//可有可无，写了能快一点</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> Point(x, y, <span class="number">0</span>));<span class="comment">//添加第一个点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.x == n &amp;&amp; p.y == m) &#123;</span><br><span class="line">                System.out.println(p.step);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                x = p.x + mx[i];</span><br><span class="line">                y = p.y + my[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; y &lt;= m &amp;&amp; !flag[x][y] &amp;&amp; g[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Point(x, y, p.step + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String[] strs = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">        m = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            strs = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) g[i][j] = Integer.parseInt(strs[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        in.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码。。。。不是一般的难。要素过多先跳过</span></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line">Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//add()和offer()都可poll(),isEmpty(),</span></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储键值对</span></span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);<span class="comment">//存</span></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>);<span class="comment">//找到a对应的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码 难点:二维数组与一维数组的相互转换</span></span><br><span class="line"><span class="comment">//x=k/3;y=k%3;k=x*3+b;互为逆运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//交换函数</span></span><br><span class="line">        <span class="keyword">char</span> temp=arr[a];</span><br><span class="line">        arr[a]=arr[b];</span><br><span class="line">        arr[b]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start,String end)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line">        queue.add(start);<span class="comment">//存初值</span></span><br><span class="line">        map.put(start,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx[]=&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//向量坐标</span></span><br><span class="line">        <span class="keyword">int</span> my[]=&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            String t=queue.poll();<span class="comment">//弹出并返回队列头</span></span><br><span class="line">            <span class="keyword">if</span>(t.equals(end))<span class="comment">//判断是否为最终结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(map.get(t));<span class="comment">//输出次数返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k=t.indexOf(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//寻找并返回‘x&#x27;一维下标</span></span><br><span class="line">            <span class="keyword">int</span> xx=k/<span class="number">3</span>,yy=k%<span class="number">3</span>;<span class="comment">//一维转二维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//遍历四种可能</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=xx+mx[i];</span><br><span class="line">                <span class="keyword">int</span> y=yy+my[i];</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">3</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;<span class="number">3</span>)<span class="comment">//不越界即可</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> arr[]=t.toCharArray();<span class="comment">//转字符数组</span></span><br><span class="line">                    swap(arr,k,x*<span class="number">3</span>+y);<span class="comment">//交换</span></span><br><span class="line">                    String s=<span class="keyword">new</span> String(arr);<span class="comment">//转回字符串</span></span><br><span class="line">                    <span class="keyword">if</span>(map.get(s)==<span class="keyword">null</span>)<span class="comment">//没出现过则保存，反之跳过</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.add(s);</span><br><span class="line">                        map.put(s,map.get(t)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String start=in.readLine();<span class="comment">//接收字符串</span></span><br><span class="line">        start=start.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//删除空格</span></span><br><span class="line">        String end=<span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">        bfs(start,end);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-树和图的深度优先搜索"><a href="#3-树和图的深度优先搜索" class="headerlink" title="3.树和图的深度优先搜索"></a>3.树和图的深度优先搜索</h3><p>树是无环连通图，图分有相图和无向图，无向图是特殊的有向图，</p>
<p>有向图两种存储方式，邻接矩阵和邻接表</p>
<h5 id="邻接表存储法"><a href="#邻接表存储法" class="headerlink" title="邻接表存储法"></a>邻接表存储法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],idx;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tf[u]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">0</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!tf[j])&#123;</span><br><span class="line">            dfs(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.fill(h,-<span class="number">1</span>);<span class="comment">//初始化所有头节点</span></span><br></pre></td></tr></table></figure>

<h4 id="树和图的深度优先遍历"><a href="#树和图的深度优先遍历" class="headerlink" title="树和图的深度优先遍历"></a>树和图的深度优先遍历</h4><h5 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tf[u]=<span class="keyword">true</span>;<span class="comment">//标记节点</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//当节点没有被标记</span></span><br><span class="line">            <span class="keyword">int</span> s=dfs(j);<span class="comment">//</span></span><br><span class="line">            sum+=s;<span class="comment">//sum记录所有子树的节点树的和</span></span><br><span class="line">            res=Math.max(res,s);<span class="comment">//所有子树节点的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=Math.max(res,n-sum);<span class="comment">//n-sum是除去所有子树节点之和后的节点数</span></span><br><span class="line">    min=Math.min(min,res);<span class="comment">//记录最大值中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="树和图的广度优先遍历"><a href="#树和图的广度优先遍历" class="headerlink" title="树和图的广度优先遍历"></a>树和图的广度优先遍历</h4><h5 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Point&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//入队，从一开始遍历</span></span><br><span class="line">    tf[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Point p=queue.poll();<span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>(p.x==n)<span class="keyword">return</span> p.step;<span class="comment">//第一个找到n的就是最小值到达n就返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[p.x];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//判断是否在队列中，在说明当前路径不会更小</span></span><br><span class="line">                tf[j]=<span class="keyword">true</span>;<span class="comment">//标记走过</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> Point(j,p.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4.拓扑排序"></a>4.拓扑排序</h3><p>有向无环图一定存在拓扑序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;<span class="comment">//所有入度为0的点全部入队</span></span><br><span class="line">            queue.add(i);</span><br><span class="line">            q[++tt]=i;<span class="comment">//存序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            arr[j]--;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(j);</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tt==n)<span class="comment">//所有点全部入队说明有拓扑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            System.out.print(q[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">  	<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="5-最短路问题"><a href="#5-最短路问题" class="headerlink" title="5.最短路问题"></a>5.最短路问题</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF.png" alt="最短路"></p>
<h4 id="（1）朴素Dijkstra算法"><a href="#（1）朴素Dijkstra算法" class="headerlink" title="（1）朴素Dijkstra算法"></a>（1）朴素Dijkstra算法</h4><p>稠密图使用，权值为正，基于贪心</p>
<p>1.初始化第一个点为0，其余点为正无穷大</p>
<p>2.找到当前最短距离，标记，其不能再更新，并用当前最短更新其他点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>][<span class="number">510</span>],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>],n;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Arrays.fill(dist,N);</span><br><span class="line">       dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化到自身为0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历所有点</span></span><br><span class="line">           <span class="keyword">int</span> t=-<span class="number">1</span>;<span class="comment">//用来存当前最短路径的点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">               <span class="comment">//判断t==-1其实是为了避免dist[t]越界，</span></span><br><span class="line">               <span class="keyword">if</span>(!tf[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j]))&#123;<span class="comment">//找当前最短路径</span></span><br><span class="line">                   t=j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           tf[t]=<span class="keyword">true</span>;<span class="comment">//找到最短路段并把它加入集合中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//用当前最短的路径来更新其他点</span></span><br><span class="line">               dist[j]=Math.min(dist[j],dist[t]+arr[t][j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(dist[n]==N) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="comment">//初始化，邻接表都需要考虑重边</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">       Arrays.fill(arr[i],N);</span><br><span class="line"><span class="comment">//接收边</span></span><br><span class="line">	arr[x][y]=Math.min(arr[x][y],z);<span class="comment">//避免重边</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）堆优化版的Dijkstra"><a href="#（2）堆优化版的Dijkstra" class="headerlink" title="（2）堆优化版的Dijkstra"></a>（2）堆优化版的Dijkstra</h4><p>稀疏图用法，权值为正</p>
<p>用堆优化，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小根堆的初始化</span></span><br><span class="line"><span class="keyword">static</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">150010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],w[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx,n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];&#125;);<span class="comment">//优先队列</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="comment">//邻接表</span></span><br><span class="line">        e[idx]=y;</span><br><span class="line">        w[idx]=z;</span><br><span class="line">        ne[idx]=h[x];</span><br><span class="line">        h[x]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化第一个点</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);<span class="comment">//并加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] t=queue.poll();<span class="comment">//弹出对头</span></span><br><span class="line">            <span class="keyword">int</span> u=t[<span class="number">0</span>],dis=t[<span class="number">1</span>];<span class="comment">//获取对头元素并弹出，点和路径；</span></span><br><span class="line">            <span class="keyword">if</span>(tf[u])&#123;<span class="comment">//减枝，可以避免重复插入同一个点（可以没有）</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tf[u]=<span class="keyword">true</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历</span></span><br><span class="line">                <span class="keyword">int</span> j=e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;dis+w[i])&#123;<span class="comment">//如果当前路径不是最短更新</span></span><br><span class="line">                    dist[j]=dis+w[i];</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;j,dist[j]&#125;);<span class="comment">//加入堆</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//邻接表初始化</span></span><br><span class="line">    Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//接收</span></span><br><span class="line">    add(x,y,z);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（3）bellman-ford算法"><a href="#（3）bellman-ford算法" class="headerlink" title="（3）bellman_ford算法"></a>（3）bellman_ford算法</h4><p>权值可以是负数</p>
<p>迭代k次，遍历所有边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>][<span class="number">3</span>],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>],n,m,k;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,N);<span class="comment">//初始化</span></span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//到自身为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//进行k次松弛操作</span></span><br><span class="line">            <span class="comment">//对距离数组进行备份，在上一次操作的基础上进行更新，不备份会导致同一次松弛操作中，前一次更新，影响后一次更新</span></span><br><span class="line">            <span class="keyword">int</span>[] temp=Arrays.copyOf(dist,<span class="number">510</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;<span class="comment">//遍历所有边</span></span><br><span class="line">                <span class="keyword">int</span> x=arr[j][<span class="number">0</span>],y=arr[j][<span class="number">1</span>],z=arr[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">//如果当前最短路径大于上一点到当前点的路径，则更新；</span></span><br><span class="line">                <span class="comment">//更新的前提：前一点（上一次松弛操作中dist[x]）（temp[x]）变小，dist[y]才可能更新         //每次更新不能影响下一次更新，只受上一次松弛操作（即i-1次松弛操作的结果）的影响</span></span><br><span class="line">                dist[y]=Math.min(dist[y],temp[x]+z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可能1到不了n点，1或不连通，有可能会被前一个N更新成为一个小于N的数</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]&gt;N/<span class="number">2</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//存储m条边，可以用数组或类对象</span></span><br><span class="line">            arr[i][<span class="number">0</span>]=cin.nextInt();</span><br><span class="line">            arr[i][<span class="number">1</span>]=cin.nextInt();</span><br><span class="line">            arr[i][<span class="number">2</span>]=cin.nextInt();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）spfa算法O-m-O-nm"><a href="#（4）spfa算法O-m-O-nm" class="headerlink" title="（4）spfa算法O(m)-O(nm)"></a>（4）spfa算法O(m)-O(nm)</h4><p>有更新过的点去更新其他点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],w[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx,n,m;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];<span class="comment">//避免重复添加一个点</span></span><br><span class="line">   <span class="keyword">static</span> Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//用队列存储点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">       e[idx]=y;</span><br><span class="line">       w[idx]=z;</span><br><span class="line">       ne[idx]=h[x];</span><br><span class="line">       h[x]=idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Arrays.fill(dist,INF);<span class="comment">//初始化</span></span><br><span class="line">       dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//把第一个点加入队列</span></span><br><span class="line">       queue.add(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> t=queue.poll();<span class="comment">//弹出对头</span></span><br><span class="line">           tf[t]=<span class="keyword">false</span>;<span class="comment">//出队改回标记，可以重新入队</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历该起点链接的所有点</span></span><br><span class="line">               <span class="keyword">int</span> j=e[i];</span><br><span class="line">               <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;<span class="comment">//判断当前路径不是最短，则更新</span></span><br><span class="line">                   dist[j]=dist[t]+w[i];</span><br><span class="line">                   <span class="comment">//注意的是如果该点已经在队列中的话就不需要再入队，所有要判断一下</span></span><br><span class="line">                   <span class="comment">//不在队列中再入队</span></span><br><span class="line">                   <span class="keyword">if</span>(!tf[j])&#123;</span><br><span class="line">                       queue.add(j);</span><br><span class="line">                       tf[j]=<span class="keyword">true</span>;<span class="comment">//入队后标记状态</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果n点没有更新说明到达不了，没有路径</span></span><br><span class="line">       <span class="keyword">if</span>(dist[n]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">       Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">       add(x,y,z);</span><br></pre></td></tr></table></figure>

<h4 id="（5）spfa求负权回路"><a href="#（5）spfa求负权回路" class="headerlink" title="（5）spfa求负权回路"></a>（5）spfa求负权回路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">get_spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//把所有点入队</span></span><br><span class="line">           queue.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> t=queue.poll();</span><br><span class="line">           tf[t]=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">               <span class="keyword">int</span> j=e[i];</span><br><span class="line">               <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="line">                   cnt[j]=cnt[t]+<span class="number">1</span>;<span class="comment">//每次更新记下次数</span></span><br><span class="line">                   <span class="keyword">if</span>(cnt[j]&gt;=n)&#123;<span class="comment">//如果更新次数大与n-1次说明有负权回路存在</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回推出</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   dist[j]=dist[t]+w[i];<span class="comment">//更新</span></span><br><span class="line">                   <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//判断是否再队列中</span></span><br><span class="line">                       tf[j]=<span class="keyword">true</span>;</span><br><span class="line">                       queue.add(j);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）floyd算法"><a href="#（6）floyd算法" class="headerlink" title="（6）floyd算法"></a>（6）floyd算法</h4><p>基于动态规划，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dist[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">210</span>][<span class="number">210</span>],n;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    dist[i][j]=Math.min(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)dist[i][j]=<span class="number">0</span>;<span class="comment">//避免自环</span></span><br><span class="line">                <span class="keyword">else</span> dist[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//接收</span></span><br><span class="line">            dist[x][y]=Math.min(dist[x][y],z);<span class="comment">//避免重边覆盖    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> y=cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(dist[x][y]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="comment">//，有可能更新出一个一个权值较大的路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(dist[x][y]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（7）prim求最小生成树"><a href="#（7）prim求最小生成树" class="headerlink" title="（7）prim求最小生成树"></a>（7）prim求最小生成树</h4><p>和dijkstra算法差不多，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[N][N],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N]，n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录总路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tf[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j])) t=j;</span><br><span class="line">            &#125;</span><br><span class="line">            tf[t]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;dist[t]==INF)<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//此路不通</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)res+=dist[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//更新t到j的距离</span></span><br><span class="line">                dist[j]=Math.min(dist[j],arr[t][j]);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n; j++)</span><br><span class="line">                arr[i][j]=INF;</span><br><span class="line">   <span class="comment">//接收</span></span><br><span class="line">            arr[x][y]=arr[y][x]=Math.min(arr[x][y],z);</span><br></pre></td></tr></table></figure>

<h4 id="（8）kruskal算法求最小生成树"><a href="#（8）kruskal算法求最小生成树" class="headerlink" title="（8）kruskal算法求最小生成树"></a>（8）kruskal算法求最小生成树</h4><p>1.按权值大小排序，遍历所有边</p>
<p>2.查看两端是否在树上，不在就连一条边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt;</span>&#123;<span class="comment">//存储边</span></span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x=x;</span><br><span class="line">            <span class="keyword">this</span>.y=y;</span><br><span class="line">            <span class="keyword">this</span>.z=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge e)</span></span>&#123;<span class="comment">//重写比较器</span></span><br><span class="line">            <span class="keyword">return</span> Integer.compare(z,e.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> Edge edge[]=<span class="keyword">new</span> Edge[M];<span class="comment">//类对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],n,m;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//并查集</span></span><br><span class="line">        <span class="keyword">if</span>(p[x]!=x)&#123;</span><br><span class="line">            p[x]=find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;<span class="comment">//主函数</span></span><br><span class="line">        Arrays.sort(edge,<span class="number">0</span>,m);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>，cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//遍历所有边</span></span><br><span class="line">            <span class="keyword">int</span> x=edge[i].x,y=edge[i].y,z=edge[i].z;</span><br><span class="line">            x=find(x),y=find(y);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)&#123;<span class="comment">//不在集合就加入，因为排过序，所以保证了没一条新加入树的边都是最短的</span></span><br><span class="line">                p[x]=y;</span><br><span class="line">                res+=z;<span class="comment">//累加</span></span><br><span class="line">                cnt++;<span class="comment">//记录边数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;n-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//边的数量不对说明不存在最小生成树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//并查集的初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">            edge[i]=<span class="keyword">new</span> Edge(x,y,z);<span class="comment">//存储</span></span><br></pre></td></tr></table></figure>

<h4 id="（9）-染色法判定二分图"><a href="#（9）-染色法判定二分图" class="headerlink" title="（9） 染色法判定二分图"></a>（9） 染色法判定二分图</h4><p>对某个点进行染色，更新其他点的颜色，没有冲突就是二分图</p>
<p>二分图没有奇数环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> colour[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//邻接表存点</span></span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">get_colour</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//每次一条路染到黑，有冲突就结束</span></span><br><span class="line">        colour[u]=c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(colour[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!get_colour(j,<span class="number">3</span>-c))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(colour[j]==c)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//接收 </span></span><br><span class="line">            add(a,b);<span class="comment">//无向图连两条相反边即可</span></span><br><span class="line">            add(b,a);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//小标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colour[i]==<span class="number">0</span>)&#123;<span class="comment">//没有被染色的就默认染上1</span></span><br><span class="line">            	<span class="keyword">if</span>(!get_colour(i,<span class="number">1</span>))&#123;</span><br><span class="line">                	flag=<span class="keyword">false</span>;</span><br><span class="line">                	System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                	<span class="keyword">break</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-二分图最大匹配"><a href="#10-二分图最大匹配" class="headerlink" title="(10)二分图最大匹配"></a>(10)二分图最大匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M=<span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],idx;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> match[]=<span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[M];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//邻接表</span></span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> g)</span></span>&#123;<span class="comment">//找匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[g];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//找一个匹配点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//没有在本轮被匹配</span></span><br><span class="line">                tf[j]=<span class="keyword">true</span>;<span class="comment">//标号</span></span><br><span class="line">                <span class="comment">//有可能没被匹配，也可能已经上一轮的其他点匹配，找它的上一个点试试能不能去寻找其他点的匹配，如果找到，则把当前点匹配成功，如果找不到，就继续向下找，如果一个都找不到就返回false;</span></span><br><span class="line">                <span class="keyword">if</span>(match[j]==<span class="number">0</span>||find(match[j]))&#123;</span><br><span class="line">                    match[j]=g;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>)</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">            add(a,b);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;<span class="comment">//遍历其中一个集合的点</span></span><br><span class="line">            Arrays.fill(tf,<span class="keyword">false</span>);<span class="comment">//初始化标记</span></span><br><span class="line">            <span class="keyword">if</span>(find(i))res++;<span class="comment">//找到匹配加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h4 id="1-试除法判定质数"><a href="#1-试除法判定质数" class="headerlink" title="(1)试除法判定质数"></a>(1)试除法判定质数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;<span class="comment">//i*i小于等于n</span></span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2-分解质因数"><a href="#（2-分解质因数" class="headerlink" title="（2)分解质因数"></a>（2)分解质因数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">re_Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot; &quot;</span>+res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)System.out.println(n+<span class="string">&quot; &quot;</span>+<span class="number">1</span>);<span class="comment">//如果你！=1，说明还有一个最大的质数</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-筛子质数"><a href="#3-筛子质数" class="headerlink" title="(3)筛子质数"></a>(3)筛子质数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//一般筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tf[i])primes[++ans]=i;<span class="comment">//把质数存起来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) tf[j]=<span class="keyword">true</span>;<span class="comment">//j=j+i就是要把质数为i的数筛掉，如10=5+5-&gt;15=10+5,注意的是j包括所有数不只是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//埃氏筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!tf[i])&#123;</span><br><span class="line">               primes[++ans]=i;<span class="comment">//</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i) tf[j]=<span class="keyword">true</span>;<span class="comment">//这里的j全是当前质数的倍数，和一般筛法比较快(相当于剪枝)</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tf[i])primes[++ans]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;primes[j]&lt;=n/i;j++)&#123;<span class="comment">//每次都用最小的质数筛掉</span></span><br><span class="line">                   tf[primes[j]*i]=<span class="keyword">true</span>;<span class="comment">//</span></span><br><span class="line">                   <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="（1）试除法求约数"><a href="#（1）试除法求约数" class="headerlink" title="（1）试除法求约数"></a>（1）试除法求约数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_approximate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ap[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">500</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ap[ans++]=i;</span><br><span class="line">            <span class="keyword">if</span>(i!=n/i)ap[ans++]=n/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(ap,<span class="number">0</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）约数个数"><a href="#（2）约数个数" class="headerlink" title="（2）约数个数"></a>（2）约数个数</h4><p>利用组合：如果n=p$_1$$^k$$^1$ p$_2$$^k$$^2$p$_3$$^k$$^3$  那它的约数个数就等于（k1+1)(k2+1)(k3+1),即求质因子的组合个数，其中1相当于1$^0$所以不考虑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//求质因子及其个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+res);<span class="comment">//对应键值对加上质数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)map.put(n,map.getOrDefault(n,<span class="number">0</span>)+<span class="number">1</span>);   </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> nums: map.values())<span class="comment">//获取键值对的值</span></span><br><span class="line">        ans=(ans*(nums+<span class="number">1</span>))%mod;</span><br></pre></td></tr></table></figure>



<h4 id="（3）约数之和"><a href="#（3）约数之和" class="headerlink" title="（3）约数之和"></a>（3）约数之和</h4><p>如果n=p$_1$$^k$$^1$ p$_2$$^k$$^2$p$_3$$^k$$^3$, 哪它约数和就为 (p$_1$$^k$$^1$+p$_1$$^k$$^1$$$^-$$$^1$+…..+p$_1$$^0$)  *  (p$_2$$^k$$^2$+p$_2$$^k$$^2$$$^-$$$^1$+…..+p$_2$$^0$)*(p$_3$$^k$$^3$+p$_3$$^k$$^3$$$^-$$$^1$+…..+p$_3$$^0$)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt;entry : map.entrySet())&#123;<span class="comment">//遍历哈希表</span></span><br><span class="line">     <span class="keyword">int</span> key=entry.getKey();</span><br><span class="line">     <span class="keyword">int</span> val=entry.getValue();</span><br><span class="line">     <span class="keyword">long</span> sum=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(val--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         sum=(sum*key+<span class="number">1</span>)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     ans=(sum*ans)%mod;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="（4）最大公约数"><a href="#（4）最大公约数" class="headerlink" title="（4）最大公约数"></a>（4）最大公约数</h4><p>辗转相除法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&gt;<span class="number">0</span>? gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="（1）欧拉函数"><a href="#（1）欧拉函数" class="headerlink" title="（1）欧拉函数"></a>（1）欧拉函数</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20211211220230.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_Eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) n=n/i;</span><br><span class="line">        sum=sum-sum/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)sum=sum-sum/n;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）筛法求欧拉函数"><a href="#（2）筛法求欧拉函数" class="headerlink" title="（2）筛法求欧拉函数"></a>（2）筛法求欧拉函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">long</span> eulers[]=<span class="keyword">new</span> <span class="keyword">long</span>[N];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> primes[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ans;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">long</span>  <span class="title">get_Eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       eulers[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!tf[i])&#123;</span><br><span class="line">               primes[ans++]=i;</span><br><span class="line">               eulers[i]=i-<span class="number">1</span>;<span class="comment">//质数的欧拉函数是其本身减一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;</span><br><span class="line">               tf[primes[j]*i]=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123;<span class="comment">//如果primes[j]是i的最小质数，那么primes[j]*i的欧拉函数就为i的欧拉函数乘上primes[j]，因为欧拉函数只和质数（p）和其本身（N）有关和指数（a）无关；</span></span><br><span class="line">                   eulers[primes[j]*i]=eulers[i]*primes[j];</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;<span class="comment">//如果i和primes[j]互质，那么primes[j]*i的欧拉函数就为i和primes[j]欧拉函数的和；</span></span><br><span class="line">               <span class="keyword">else</span> eulers[primes[j]*i]=eulers[i]*eulers[primes[j]];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           eulers[i]+=eulers[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> eulers[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h4 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h4><p>能快速求出a$^b$%p的值把 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get_Quick</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>)res=res*a%p;<span class="comment">//当二进制数位上为一时</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;<span class="comment">//每次把k最后一位删掉</span></span><br><span class="line">        a=a*a%p;<span class="comment">//每次都跟新a的指数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20211212123800.png"></p>
<p>其实就是找到一个x  1=b$<em>$x(mod m)   当m为质数时 由费马定理   b$^m$$^-$$^1$(mod m)=1    b$</em>$b$^m$$^-$$^2$(mod m)=1  x=b$^m$$^-$$^2$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b%m==<span class="number">0</span>)System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(get_Qmi(a,m-<span class="number">2</span>,m));</span><br></pre></td></tr></table></figure>



<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>裴蜀定理：有一对正整数a,b,那么一定存在整数x，y,使得 ax+ay=gcd(a,b)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x,y;<span class="comment">//java没有变量引用，开全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b%d==<span class="number">0</span>)<span class="comment">//线性同余方程转换为欧几里得算法，当b是最大公约数d的倍数时有解</span></span><br><span class="line">	System.out.println(b/d*x%m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h4 id="（1）-高斯消元接解线性方程组"><a href="#（1）-高斯消元接解线性方程组" class="headerlink" title="（1） 高斯消元接解线性方程组"></a>（1） 高斯消元接解线性方程组</h4><h4 id="（2）高斯消元解异或线性方程组"><a href="#（2）高斯消元解异或线性方程组" class="headerlink" title="（2）高斯消元解异或线性方程组"></a>（2）高斯消元解异或线性方程组</h4><h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="（1）Nim游戏"><a href="#（1）Nim游戏" class="headerlink" title="（1）Nim游戏"></a>（1）Nim游戏</h4><h4 id="（2）台阶"><a href="#（2）台阶" class="headerlink" title="（2）台阶"></a>（2）台阶</h4><h4 id="（3）集合"><a href="#（3）集合" class="headerlink" title="（3）集合"></a>（3）集合</h4><h4 id="（4）拆分"><a href="#（4）拆分" class="headerlink" title="（4）拆分"></a>（4）拆分</h4>
      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-12-07 23:58:51
            </span>
            
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><span class="toc-text">算法笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO-%E6%B5%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">Java IO 流模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AC%ACK%E4%B8%AA%E6%95%B0"><span class="toc-text">2.第K个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">3.归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">4.逆序对的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%88%86"><span class="toc-text">5.二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-text">数的范围  整数二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9-%E5%B0%8F%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-text">三次方根  小数二分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">6.前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B7%AE%E5%88%86"><span class="toc-text">7.差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">8.双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">9.位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-text">10.离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-text">11.区间合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">1.单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">2.双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88"><span class="toc-text">3.栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97"><span class="toc-text">4.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">5.单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-text">6.单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-kmp"><span class="toc-text">7.kmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1"><span class="toc-text">8.Trie字符串统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">9.并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A0%86"><span class="toc-text">10.堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">11.哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-text">开放寻址法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-text">字符串哈希</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E5%9B%BE%E8%AE%BA"><span class="toc-text">搜索和图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-text">1.深度优先搜索 DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS"><span class="toc-text">2.宽度优先搜索BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">3.树和图的深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%B3%95"><span class="toc-text">邻接表存储法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">树和图的深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-text">树的重心</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">树和图的广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-text">图中点的层次</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">4.拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-text">5.最短路问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9C%B4%E7%B4%A0Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">（1）朴素Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88%E7%9A%84Dijkstra"><span class="toc-text">（2）堆优化版的Dijkstra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89bellman-ford%E7%AE%97%E6%B3%95"><span class="toc-text">（3）bellman_ford算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89spfa%E7%AE%97%E6%B3%95O-m-O-nm"><span class="toc-text">（4）spfa算法O(m)-O(nm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89spfa%E6%B1%82%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF"><span class="toc-text">（5）spfa求负权回路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89floyd%E7%AE%97%E6%B3%95"><span class="toc-text">（6）floyd算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89prim%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">（7）prim求最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89kruskal%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">（8）kruskal算法求最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text">（9） 染色法判定二分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-text">(10)二分图最大匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="toc-text">数学知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0"><span class="toc-text">质数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0"><span class="toc-text">(1)试除法判定质数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-text">（2)分解质因数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AD%9B%E5%AD%90%E8%B4%A8%E6%95%B0"><span class="toc-text">(3)筛子质数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0"><span class="toc-text">约数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="toc-text">（1）试除法求约数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-text">（2）约数个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">（3）约数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-text">（4）最大公约数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-text">欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-text">（1）欧拉函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-text">（2）筛法求欧拉函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82-1"><span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-text">快速幂求逆元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-text">高斯消元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%8E%A5%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-text">（1） 高斯消元接解线性方程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-text">（2）高斯消元解异或线性方程组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-text">求组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="toc-text">容斥原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-text">博弈论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Nim%E6%B8%B8%E6%88%8F"><span class="toc-text">（1）Nim游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%B0%E9%98%B6"><span class="toc-text">（2）台阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%9B%86%E5%90%88"><span class="toc-text">（3）集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%8B%86%E5%88%86"><span class="toc-text">（4）拆分</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        





      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="facebook" href="">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" href="">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="wechat" href="">
            <i class="iconfont icon-wechat"></i>
          </a>
        </li>
      
        <li>
          <a title="weibo" href="">
            <i class="iconfont icon-weibo"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © Oranges 2021</a>
        
    </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0 + '&url=' + http%3A%2F%2Fexample.com%2F2021%2F12%2F07%2F%25E7%25AE%2597%25E6%25B3%2595%25E7%25AC%2594%25E8%25AE%25B0%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
