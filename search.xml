<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法笔记</title>
      <link href="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="Java-IO-流模板"><a href="#Java-IO-流模板" class="headerlink" title="Java IO 流模板"></a>Java IO 流模板</h2><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> BufferedWriter out=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one=Integer.parseInt(in.readLine());<span class="comment">//单字符输入</span></span><br><span class="line">        String[] s1=reder.readLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//多字符用字符数组接收再转类型</span></span><br><span class="line">        <span class="keyword">int</span> n=Integer.parseInt(s1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m=Integer.parseInt(s1[<span class="number">1</span>]);</span><br><span class="line">        String s=in.readLine();<span class="comment">//字符串输入</span></span><br><span class="line">        out.write();<span class="comment">//打印输出</span></span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        StreamTokenizer in=<span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">        PrintWriter out=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">while</span>(in.nextToken()!=StreamTokenizer.TT_EOF)&#123;<span class="comment">//文件结束不再接收</span></span><br><span class="line">            <span class="keyword">int</span> n=(<span class="keyword">int</span>) in.nval;</span><br><span class="line">            in.nextToken();<span class="comment">//每次输入后必需写，让其向后读取直到eof</span></span><br><span class="line">            String s1=in.sval;<span class="comment">//只能接收纯字母，其它接收失败</span></span><br><span class="line">            in.nextToken();</span><br><span class="line">            out.println(n);<span class="comment">//打印输出</span></span><br><span class="line">           out.flush();</span><br><span class="line">          out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=arr[left+right&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=left-<span class="number">1</span>,r=right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++l]&lt;mid);</span><br><span class="line">        <span class="keyword">while</span>(arr[--r]&gt;mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)swap(arr[l],arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">        quick_sort(left,r);</span><br><span class="line">        quick_sort(r+<span class="number">1</span>,right);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-第K个数"><a href="#2-第K个数" class="headerlink" title="2.第K个数"></a>2.第K个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>],k;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quick_k</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> arr[left];</span><br><span class="line">    <span class="keyword">int</span> mid=arr[left+right&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=left-<span class="number">1</span>,r=right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++l]&lt;mid);</span><br><span class="line">        <span class="keyword">while</span>(arr[--r]&gt;mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)swap(arr[l],arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=r-k+<span class="number">1</span>;<span class="comment">//利用快排分治，只需确定第k个数所在区间</span></span><br><span class="line">    <span class="keyword">if</span>(flag&gt;=<span class="number">0</span>)<span class="keyword">return</span> quick_k(left,r);<span class="comment">//k在左区间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_k(r+<span class="number">1</span>,right); <span class="comment">//在右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];<span class="comment">//开多一个临时数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meger_sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先分后治</span></span><br><span class="line">    meger_sort(left,mid);</span><br><span class="line">    meger_sort(mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">int</span> l=left,r=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=right) temp[k++]=arr[l]&lt;=arr[r]?arr[l++]:arr[r++];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid) temp[k++]=arr[l++];</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=right) temp[k++]=arr[r++];</span><br><span class="line">    <span class="keyword">for</span>(l=left,k=<span class="number">0</span>;l&lt;=right;l++,k++) arr[l]=temp[k]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-逆序对的数量"><a href="#4-逆序对的数量" class="headerlink" title="4.逆序对的数量"></a>4.逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span>   <span class="number">10</span>  <span class="number">12</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">3</span>   <span class="number">10</span>  <span class="number">12</span> </span><br><span class="line"><span class="number">4</span> 和 <span class="number">5</span> 为逆序对，也分别和 <span class="number">3</span> 互为逆序对</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meger_ans</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       meger_ans(left,mid);</span><br><span class="line">       meger_ans(mid+<span class="number">1</span>,right);</span><br><span class="line">       <span class="keyword">int</span> l=left,r=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(l&lt;=mid&amp;&amp;r&lt;=right)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[l]&lt;=arr[r])</span><br><span class="line">               temp[k++]=arr[l++];</span><br><span class="line">           <span class="keyword">else</span>&#123;<span class="comment">//ans记录逆序对的数量</span></span><br><span class="line">               ans+=mid-l+<span class="number">1</span>;</span><br><span class="line">               temp[k++]=arr[r++]; </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(l&lt;=mid)temp[k++]=arr[l++];</span><br><span class="line">       <span class="keyword">while</span>(r&lt;=right)temp[k++]=arr[r++];</span><br><span class="line">       <span class="keyword">for</span>(l=left,k=<span class="number">0</span>;l&lt;=right;l++,k++)arr[l]=temp[k];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-二分"><a href="#5-二分" class="headerlink" title="5.二分"></a>5.二分</h3><h4 id="数的范围-整数二分"><a href="#数的范围-整数二分" class="headerlink" title="数的范围  整数二分"></a>数的范围  整数二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左区间</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;=k) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]!=k)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>+<span class="string">&quot; &quot;</span>+-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.print(left+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            right=n-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右区间</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=left+right+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid]&lt;=k) left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(left);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="三次方根-小数二分"><a href="#三次方根-小数二分" class="headerlink" title="三次方根  小数二分"></a>三次方根  小数二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> left=-<span class="number">10000</span>,right=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(res*res*res-n&gt;<span class="number">1e-8</span>||n-res*res*res&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">res=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(res*res*res&gt;n) right=res;</span><br><span class="line"><span class="keyword">else</span> left=res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.6f&quot;</span>+<span class="string">&quot;\n&quot;</span>,res);</span><br></pre></td></tr></table></figure><h3 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6.前缀和"></a>6.前缀和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">arr[i]+=arr[i-<span class="number">1</span>];</span><br><span class="line">res=arr[r]-arr[l-<span class="number">1</span>];</span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">arr[i][j]+=arr[i][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">arr[i][j]+=arr[i-<span class="number">1</span>][j];</span><br><span class="line">res=arr[x2][y2]+arr[x1-<span class="number">1</span>][y1-<span class="number">1</span>]-arr[x1-<span class="number">1</span>][y2]-arr[x2][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="7-差分"><a href="#7-差分" class="headerlink" title="7.差分"></a>7.差分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ggs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">temp[l]+=c;</span><br><span class="line">temp[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维差分</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ggs</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">temp[x1][y1]+=c;</span><br><span class="line">    temp[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    temp[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    temp[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-双指针"><a href="#8-双指针" class="headerlink" title="8.双指针"></a>8.双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//i指针</span></span><br><span class="line">temp[arr[i]]++;</span><br><span class="line"><span class="keyword">while</span>(temp[arr[i]]&gt;<span class="number">1</span>)&#123;<span class="comment">//判断j指针条件</span></span><br><span class="line">temp[arr[j]]--;</span><br><span class="line"> j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max&lt;i-j+<span class="number">1</span>)&#123;<span class="comment">//条件达成</span></span><br><span class="line">max=i-j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取二进制下k位置的数</span></span><br><span class="line">（n&gt;&gt;k）&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;-x;<span class="comment">//x&amp;(~x+1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10.离散化"></a>10.离散化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] t,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//获取排名，从开始</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=t.length;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t[mid]&gt;=x) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//排序去重</span></span><br><span class="line">        SortedSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//set可以去重并从小到大排序</span></span><br><span class="line">            set.add(x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        flag=set.size();</span><br><span class="line">        <span class="keyword">int</span> t[]=<span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> te=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur:set)&#123;<span class="comment">//把集合处理好的数放入一个临时数组中</span></span><br><span class="line">            t[te++]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp[i]=lower_bound(t,x[i])+<span class="number">1</span>;<span class="comment">//存储离散化后的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11.区间合并"></a>11.区间合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思想：从小到大排列区间头部，依次判断右边界</span></span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>全部用数组模拟</p><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne=<span class="keyword">new</span> <span class="keyword">int</span>[N],head,idx;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    head=-<span class="number">1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在头部添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    en[idx]=head;</span><br><span class="line">    head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在k后添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    en[idx]=en[k];</span><br><span class="line">    en[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> K)</span></span>&#123;<span class="comment">//删除k后的数</span></span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],l[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],r[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在k后加添加</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[r[k]]=idx;<span class="comment">//不可颠倒</span></span><br><span class="line">    r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//删除k</span></span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],tt;</span><br><span class="line"><span class="comment">//添加push</span></span><br><span class="line">q[++t]=x;</span><br><span class="line"><span class="comment">//弹出pop</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//查看栈是否为空empoty</span></span><br><span class="line"><span class="keyword">boolean</span> flag=tt&lt;=<span class="number">0</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],hh,tt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tt=-<span class="number">1</span>;</span><br><span class="line">    hh=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加push</span></span><br><span class="line">qq[++tt]=x;</span><br><span class="line"><span class="comment">//弹出pop</span></span><br><span class="line">hh++;</span><br><span class="line"><span class="comment">//查看对头元素</span></span><br><span class="line">q[hh];</span><br><span class="line"><span class="comment">//查看队列是否为空</span></span><br><span class="line"><span class="keyword">boolean</span> flag=hh&gt;=tt?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h3 id="5-单调栈"><a href="#5-单调栈" class="headerlink" title="5.单调栈"></a>5.单调栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],tt,temp;</span><br><span class="line"><span class="keyword">while</span>(tt&gt;<span class="number">0</span>&amp;&amp;q[tt]&gt;=temp)<span class="comment">//单调递增</span></span><br><span class="line">tt--;<span class="comment">//弹出所有大于temp的数</span></span><br><span class="line">q[++tt]=temp;<span class="comment">//保留temp,最后形成一个单调递增的栈</span></span><br></pre></td></tr></table></figure><h3 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6.单调队列"></a>6.单调队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> q[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],hh,tt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hh=<span class="number">0</span>;</span><br><span class="line">    tt=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找最小值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 判断队头是否已经滑出窗口, 如果滑出窗口, 则弹出队首元素,维护窗口大小不超过 k, 每次值滑动一次, 所以可以使用 if</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])</span><br><span class="line">hh++;</span><br><span class="line">    <span class="comment">// 寻找窗口中的最小值</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &gt;= arr[i]) </span><br><span class="line">tt--;</span><br><span class="line">q[++tt] = i;    <span class="comment">// 将本轮下标添加到队列中</span></span><br><span class="line">    <span class="comment">// 保证满足窗口大小, 比如窗口大小为 3, 不能此时只进入 2个数字</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) log.write(arr[q[hh]] + <span class="string">&quot; &quot;</span>);    <span class="comment">// 窗口内的最小值为队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-kmp"><a href="#7-kmp" class="headerlink" title="7.kmp"></a>7.kmp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> next[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">next[<span class="number">0</span>]=-<span class="number">1</span>;<span class="comment">//java从0开始，要初始化next[0]=-1；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=-<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//next数组生成</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;-<span class="number">1</span>&amp;&amp;p.charAt(i)!=p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.charAt(i)==p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=-<span class="number">1</span>;i&lt;m,i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;-<span class="number">1</span>&amp;&amp;s.charAt(i)!=p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i)==p.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==n-<span class="number">1</span>)&#123;</span><br><span class="line">        out.print(i-n+<span class="number">1</span>+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-Trie字符串统计"><a href="#8-Trie字符串统计" class="headerlink" title="8.Trie字符串统计"></a>8.Trie字符串统计</h3><p>把字符存在一棵树中，用一个二维数组模拟树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> son[][]=<span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>],cnt[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;<span class="comment">//idx表示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Sting str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str.charAt(i)-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//把字母映射到下标；0-25;</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>)&#123;<span class="comment">//如果当前没有存有，则标记</span></span><br><span class="line">            son[p][u]=++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//结束标记以此为下标的数的总数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str.cahAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>)&#123;<span class="comment">//从头查找，没有直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//当前找到则向下查找</span></span><br><span class="line">            p=son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];<span class="comment">//循环结束则说明有这个数返回数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9.并查集"></a>9.并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> p[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)p=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)&#123;<span class="comment">//如果本身不是头节点</span></span><br><span class="line">        <span class="comment">//继续向上寻找头节点，直到找到为止；并把当前节点指向头节点</span></span><br><span class="line">        p[x]=find(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];<span class="comment">//最后返回头节点        </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询a,b是否在同一集合</span></span><br><span class="line">find(a)==find(b)</span><br><span class="line"><span class="comment">//把a,b所在集合合并</span></span><br><span class="line">p[find(a)]=find(b);<span class="comment">//把a所在集合指向b的头节点</span></span><br><span class="line"><span class="comment">//可以用额外数组维护同一集合的数量</span></span><br><span class="line"><span class="keyword">int</span> size[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)size[i]=<span class="number">1</span>;</span><br><span class="line">size[find(b)]+=size[find(a)]</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="10-堆"><a href="#10-堆" class="headerlink" title="10.堆"></a>10.堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> heap[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],size;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//向下找最小值</span></span><br><span class="line">    <span class="keyword">int</span> u=x;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&gt;size&amp;&amp;heap[x]&gt;heap[u*<span class="number">2</span>])x=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&gt;size&amp;&amp;heap[x]&gt;heap[u*<span class="number">2</span>+<span class="number">1</span>])x=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=u)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=heap[x];</span><br><span class="line">        heap[x]=heap[u];</span><br><span class="line">        heap[u]=temp;</span><br><span class="line">        down(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//向上找更大值</span></span><br><span class="line">    <span class="keyword">if</span>(u/<span class="number">2</span>&amp;&amp;heap[u]&lt;heap[u/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=heap[u];</span><br><span class="line">        heap[u]=heap[u/<span class="number">2</span>];</span><br><span class="line">        heap[u]=temp;</span><br><span class="line">        up(u/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">size=n;<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)down(i);<span class="comment">//快速建堆</span></span><br><span class="line"><span class="comment">//删除最小值</span></span><br><span class="line">heap[<span class="number">1</span>]=heap[size--];<span class="comment">//用最后一个数覆盖第一个数，并删除最后一个数</span></span><br><span class="line">down(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除任意值</span></span><br><span class="line">heap[k]=heap[size--];</span><br><span class="line">down(k);</span><br><span class="line">up(k);</span><br><span class="line"><span class="comment">//修改任意值</span></span><br><span class="line">heap[k]=x;down(k);up(k);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-哈希表"><a href="#11-哈希表" class="headerlink" title="11.哈希表"></a>11.哈希表</h3><p>我的理解：哈希函数就是对一个质数取模，且保证他们的映射在范围之内</p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">static</span> heap[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line">Arrays.fill(heap,-<span class="number">1</span>);<span class="comment">//初始化heap，全部指向-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=heap[k];</span><br><span class="line">    heap[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=heap[k];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line">   <span class="keyword">static</span> Integer h[]=<span class="keyword">new</span> Integer[<span class="number">2</span>*N];<span class="comment">//开多倍数组</span></span><br><span class="line">Arrays.fill(h,<span class="keyword">null</span>);<span class="comment">//初始化为null,int 办不到所以要Integer</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">       <span class="keyword">while</span>(h[k]!=<span class="keyword">null</span>&amp;&amp;h[k]!=x)&#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       h[k]=x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">       <span class="keyword">while</span>(h[k]!=<span class="keyword">null</span>&amp;&amp;h[k]!=x)&#123;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(h[k]==<span class="keyword">null</span>)&#123;<span class="comment">//不能用h[k]==x作为判断条件，暂时不知道为什么</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>字符串前缀哈希法</p><p>预处理所有前缀的哈希，用到前缀和所以要从1开始，字母不能映射为0，理想状态下不存在冲突；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> P=<span class="number">131</span>;<span class="comment">//p取131或13331避免冲突，</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> h[]=<span class="keyword">new</span> <span class="keyword">long</span>[N],p[]=<span class="keyword">new</span> <span class="keyword">long</span>[N];<span class="comment">//h[]存哈希后的前缀和，p[]存预处理p的n次方，mod取2^64^,java中long超程就是对mod取模</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> str[]=<span class="keyword">new</span> <span class="keyword">char</span>[N];<span class="comment">//存字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//求一个区间内的哈希值</span></span><br><span class="line">    <span class="keyword">long</span> res=h[r]-h[l-<span class="number">1</span>]*p[r-l+<span class="number">1</span>];<span class="comment">//由高位到低位存储，最低位下标实际上就是最高位的上标</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner cin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=cin.nextInt();</span><br><span class="line">    <span class="keyword">int</span> m=cin.nextInt();</span><br><span class="line">    String s=cin.next();</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">        str[i]=s.charAt(i-<span class="number">1</span>);</span><br><span class="line">        p[i]=p[i-<span class="number">1</span>]*P;<span class="comment">//预处理</span></span><br><span class="line">        h[i]=h[i-<span class="number">1</span>]*P+str[i];<span class="comment">//前缀和</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="搜索和图论"><a href="#搜索和图论" class="headerlink" title="搜索和图论"></a>搜索和图论</h2><h3 id="1-深度优先搜索-DFS"><a href="#1-深度优先搜索-DFS" class="headerlink" title="1.深度优先搜索 DFS"></a>1.深度优先搜索 DFS</h3><p>暴力搜索所有结果，递归回溯要还原现场</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  p[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],n;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> s[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,i&lt;=n;i++)&#123;<span class="comment">//相关操作</span></span><br><span class="line">            System.out.print(p[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s[j])&#123;</span><br><span class="line">        p[j]=i;</span><br><span class="line">            s[j]=<span class="keyword">true</span>;<span class="comment">//标记</span></span><br><span class="line">            dfs(u+<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">            s[j]=<span class="keyword">false</span>;<span class="comment">//还原现场</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="2-宽度优先搜索BFS"><a href="#2-宽度优先搜索BFS" class="headerlink" title="2.宽度优先搜索BFS"></a>2.宽度优先搜索BFS</h3><p>当权值一样时有最短路概念，即优先搜索相同距离，并向外扩散，直到所有结果出现</p><p>道理都懂，代码不会实现…..</p><p>手写队列和内部队列速度差不多，代码繁琐其实不难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部数据结构queue,事实证明对于java内部队列和手写队列速度差不了多少</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;<span class="comment">//定义点类</span></span><br><span class="line">        <span class="keyword">int</span> x, y, step;<span class="comment">//存坐标和步数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.step = step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;Point&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//定义队列</span></span><br><span class="line">    <span class="comment">//add添加，isEmpty是否为空,poll弹出</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] mx = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] my = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//x,y入队</span></span><br><span class="line">        flag[<span class="number">1</span>][<span class="number">1</span>]=<span class="keyword">true</span>;<span class="comment">//可有可无，写了能快一点</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> Point(x, y, <span class="number">0</span>));<span class="comment">//添加第一个点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.x == n &amp;&amp; p.y == m) &#123;</span><br><span class="line">                System.out.println(p.step);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                x = p.x + mx[i];</span><br><span class="line">                y = p.y + my[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; y &lt;= m &amp;&amp; !flag[x][y] &amp;&amp; g[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Point(x, y, p.step + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String[] strs = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">        m = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            strs = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) g[i][j] = Integer.parseInt(strs[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        in.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码。。。。不是一般的难。要素过多先跳过</span></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line">Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//add()和offer()都可poll(),isEmpty(),</span></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存储键值对</span></span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);<span class="comment">//存</span></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>);<span class="comment">//找到a对应的值</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八数码 难点:二维数组与一维数组的相互转换</span></span><br><span class="line"><span class="comment">//x=k/3;y=k%3;k=x*3+b;互为逆运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//交换函数</span></span><br><span class="line">        <span class="keyword">char</span> temp=arr[a];</span><br><span class="line">        arr[a]=arr[b];</span><br><span class="line">        arr[b]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start,String end)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line">        queue.add(start);<span class="comment">//存初值</span></span><br><span class="line">        map.put(start,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx[]=&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//向量坐标</span></span><br><span class="line">        <span class="keyword">int</span> my[]=&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            String t=queue.poll();<span class="comment">//弹出并返回队列头</span></span><br><span class="line">            <span class="keyword">if</span>(t.equals(end))<span class="comment">//判断是否为最终结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(map.get(t));<span class="comment">//输出次数返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k=t.indexOf(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//寻找并返回‘x&#x27;一维下标</span></span><br><span class="line">            <span class="keyword">int</span> xx=k/<span class="number">3</span>,yy=k%<span class="number">3</span>;<span class="comment">//一维转二维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//遍历四种可能</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=xx+mx[i];</span><br><span class="line">                <span class="keyword">int</span> y=yy+my[i];</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">3</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;<span class="number">3</span>)<span class="comment">//不越界即可</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> arr[]=t.toCharArray();<span class="comment">//转字符数组</span></span><br><span class="line">                    swap(arr,k,x*<span class="number">3</span>+y);<span class="comment">//交换</span></span><br><span class="line">                    String s=<span class="keyword">new</span> String(arr);<span class="comment">//转回字符串</span></span><br><span class="line">                    <span class="keyword">if</span>(map.get(s)==<span class="keyword">null</span>)<span class="comment">//没出现过则保存，反之跳过</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.add(s);</span><br><span class="line">                        map.put(s,map.get(t)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String start=in.readLine();<span class="comment">//接收字符串</span></span><br><span class="line">        start=start.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//删除空格</span></span><br><span class="line">        String end=<span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">        bfs(start,end);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-树和图的深度优先搜索"><a href="#3-树和图的深度优先搜索" class="headerlink" title="3.树和图的深度优先搜索"></a>3.树和图的深度优先搜索</h3><p>树是无环连通图，图分有相图和无向图，无向图是特殊的有向图，</p><p>有向图两种存储方式，邻接矩阵和邻接表</p><h5 id="邻接表存储法"><a href="#邻接表存储法" class="headerlink" title="邻接表存储法"></a>邻接表存储法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],idx;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tf[u]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">0</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!tf[j])&#123;</span><br><span class="line">            dfs(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.fill(h,-<span class="number">1</span>);<span class="comment">//初始化所有头节点</span></span><br></pre></td></tr></table></figure><h4 id="树和图的深度优先遍历"><a href="#树和图的深度优先遍历" class="headerlink" title="树和图的深度优先遍历"></a>树和图的深度优先遍历</h4><h5 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    tf[u]=<span class="keyword">true</span>;<span class="comment">//标记节点</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//当节点没有被标记</span></span><br><span class="line">            <span class="keyword">int</span> s=dfs(j);<span class="comment">//</span></span><br><span class="line">            sum+=s;<span class="comment">//sum记录所有子树的节点树的和</span></span><br><span class="line">            res=Math.max(res,s);<span class="comment">//所有子树节点的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=Math.max(res,n-sum);<span class="comment">//n-sum是除去所有子树节点之和后的节点数</span></span><br><span class="line">    min=Math.min(min,res);<span class="comment">//记录最大值中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树和图的广度优先遍历"><a href="#树和图的广度优先遍历" class="headerlink" title="树和图的广度优先遍历"></a>树和图的广度优先遍历</h4><h5 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Point&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//入队，从一开始遍历</span></span><br><span class="line">    tf[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Point p=queue.poll();<span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>(p.x==n)<span class="keyword">return</span> p.step;<span class="comment">//第一个找到n的就是最小值到达n就返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[p.x];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//判断是否在队列中，在说明当前路径不会更小</span></span><br><span class="line">                tf[j]=<span class="keyword">true</span>;<span class="comment">//标记走过</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> Point(j,p.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4.拓扑排序"></a>4.拓扑排序</h3><p>有向无环图一定存在拓扑序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;<span class="comment">//所有入度为0的点全部入队</span></span><br><span class="line">            queue.add(i);</span><br><span class="line">            q[++tt]=i;<span class="comment">//存序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            arr[j]--;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(j);</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tt==n)<span class="comment">//所有点全部入队说明有拓扑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            System.out.print(q[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="5-最短路问题"><a href="#5-最短路问题" class="headerlink" title="5.最短路问题"></a>5.最短路问题</h3><p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF.png" alt="最短路"></p><h4 id="（1）朴素Dijkstra算法"><a href="#（1）朴素Dijkstra算法" class="headerlink" title="（1）朴素Dijkstra算法"></a>（1）朴素Dijkstra算法</h4><p>稠密图使用，权值为正，基于贪心</p><p>1.初始化第一个点为0，其余点为正无穷大</p><p>2.找到当前最短距离，标记，其不能再更新，并用当前最短更新其他点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>][<span class="number">510</span>],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>],n;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Arrays.fill(dist,N);</span><br><span class="line">       dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化到自身为0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历所有点</span></span><br><span class="line">           <span class="keyword">int</span> t=-<span class="number">1</span>;<span class="comment">//用来存当前最短路径的点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">               <span class="comment">//判断t==-1其实是为了避免dist[t]越界，</span></span><br><span class="line">               <span class="keyword">if</span>(!tf[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j]))&#123;<span class="comment">//找当前最短路径</span></span><br><span class="line">                   t=j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           tf[t]=<span class="keyword">true</span>;<span class="comment">//找到最短路段并把它加入集合中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//用当前最短的路径来更新其他点</span></span><br><span class="line">               dist[j]=Math.min(dist[j],dist[t]+arr[t][j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(dist[n]==N) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="comment">//初始化，邻接表都需要考虑重边</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">       Arrays.fill(arr[i],N);</span><br><span class="line"><span class="comment">//接收边</span></span><br><span class="line">arr[x][y]=Math.min(arr[x][y],z);<span class="comment">//避免重边</span></span><br></pre></td></tr></table></figure><h4 id="（2）堆优化版的Dijkstra"><a href="#（2）堆优化版的Dijkstra" class="headerlink" title="（2）堆优化版的Dijkstra"></a>（2）堆优化版的Dijkstra</h4><p>稀疏图用法，权值为正</p><p>用堆优化，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小根堆的初始化</span></span><br><span class="line"><span class="keyword">static</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">150010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],w[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx,n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];&#125;);<span class="comment">//优先队列</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="comment">//邻接表</span></span><br><span class="line">        e[idx]=y;</span><br><span class="line">        w[idx]=z;</span><br><span class="line">        ne[idx]=h[x];</span><br><span class="line">        h[x]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化第一个点</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);<span class="comment">//并加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] t=queue.poll();<span class="comment">//弹出对头</span></span><br><span class="line">            <span class="keyword">int</span> u=t[<span class="number">0</span>],dis=t[<span class="number">1</span>];<span class="comment">//获取对头元素并弹出，点和路径；</span></span><br><span class="line">            <span class="keyword">if</span>(tf[u])&#123;<span class="comment">//减枝，可以避免重复插入同一个点（可以没有）</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tf[u]=<span class="keyword">true</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历</span></span><br><span class="line">                <span class="keyword">int</span> j=e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;dis+w[i])&#123;<span class="comment">//如果当前路径不是最短更新</span></span><br><span class="line">                    dist[j]=dis+w[i];</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;j,dist[j]&#125;);<span class="comment">//加入堆</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//邻接表初始化</span></span><br><span class="line">    Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//接收</span></span><br><span class="line">    add(x,y,z);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（3）bellman-ford算法"><a href="#（3）bellman-ford算法" class="headerlink" title="（3）bellman_ford算法"></a>（3）bellman_ford算法</h4><p>权值可以是负数</p><p>迭代k次，遍历所有边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>][<span class="number">3</span>],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">510</span>],n,m,k;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,N);<span class="comment">//初始化</span></span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//到自身为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//进行k次松弛操作</span></span><br><span class="line">            <span class="comment">//对距离数组进行备份，在上一次操作的基础上进行更新，不备份会导致同一次松弛操作中，前一次更新，影响后一次更新</span></span><br><span class="line">            <span class="keyword">int</span>[] temp=Arrays.copyOf(dist,<span class="number">510</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;<span class="comment">//遍历所有边</span></span><br><span class="line">                <span class="keyword">int</span> x=arr[j][<span class="number">0</span>],y=arr[j][<span class="number">1</span>],z=arr[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">//如果当前最短路径大于上一点到当前点的路径，则更新；</span></span><br><span class="line">                <span class="comment">//更新的前提：前一点（上一次松弛操作中dist[x]）（temp[x]）变小，dist[y]才可能更新         //每次更新不能影响下一次更新，只受上一次松弛操作（即i-1次松弛操作的结果）的影响</span></span><br><span class="line">                dist[y]=Math.min(dist[y],temp[x]+z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可能1到不了n点，1或不连通，有可能会被前一个N更新成为一个小于N的数</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]&gt;N/<span class="number">2</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//存储m条边，可以用数组或类对象</span></span><br><span class="line">            arr[i][<span class="number">0</span>]=cin.nextInt();</span><br><span class="line">            arr[i][<span class="number">1</span>]=cin.nextInt();</span><br><span class="line">            arr[i][<span class="number">2</span>]=cin.nextInt();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="（4）spfa算法O-m-O-nm"><a href="#（4）spfa算法O-m-O-nm" class="headerlink" title="（4）spfa算法O(m)-O(nm)"></a>（4）spfa算法O(m)-O(nm)</h4><p>有更新过的点去更新其他点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],w[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx,n,m;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];<span class="comment">//避免重复添加一个点</span></span><br><span class="line">   <span class="keyword">static</span> Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//用队列存储点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">       e[idx]=y;</span><br><span class="line">       w[idx]=z;</span><br><span class="line">       ne[idx]=h[x];</span><br><span class="line">       h[x]=idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Arrays.fill(dist,INF);<span class="comment">//初始化</span></span><br><span class="line">       dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//把第一个点加入队列</span></span><br><span class="line">       queue.add(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> t=queue.poll();<span class="comment">//弹出对头</span></span><br><span class="line">           tf[t]=<span class="keyword">false</span>;<span class="comment">//出队改回标记，可以重新入队</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//遍历该起点链接的所有点</span></span><br><span class="line">               <span class="keyword">int</span> j=e[i];</span><br><span class="line">               <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;<span class="comment">//判断当前路径不是最短，则更新</span></span><br><span class="line">                   dist[j]=dist[t]+w[i];</span><br><span class="line">                   <span class="comment">//注意的是如果该点已经在队列中的话就不需要再入队，所有要判断一下</span></span><br><span class="line">                   <span class="comment">//不在队列中再入队</span></span><br><span class="line">                   <span class="keyword">if</span>(!tf[j])&#123;</span><br><span class="line">                       queue.add(j);</span><br><span class="line">                       tf[j]=<span class="keyword">true</span>;<span class="comment">//入队后标记状态</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果n点没有更新说明到达不了，没有路径</span></span><br><span class="line">       <span class="keyword">if</span>(dist[n]==INF) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">       Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">       add(x,y,z);</span><br></pre></td></tr></table></figure><h4 id="（5）spfa求负权回路"><a href="#（5）spfa求负权回路" class="headerlink" title="（5）spfa求负权回路"></a>（5）spfa求负权回路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">get_spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Queue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//把所有点入队</span></span><br><span class="line">           queue.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> t=queue.poll();</span><br><span class="line">           tf[t]=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">               <span class="keyword">int</span> j=e[i];</span><br><span class="line">               <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="line">                   cnt[j]=cnt[t]+<span class="number">1</span>;<span class="comment">//每次更新记下次数</span></span><br><span class="line">                   <span class="keyword">if</span>(cnt[j]&gt;=n)&#123;<span class="comment">//如果更新次数大与n-1次说明有负权回路存在</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回推出</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   dist[j]=dist[t]+w[i];<span class="comment">//更新</span></span><br><span class="line">                   <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//判断是否再队列中</span></span><br><span class="line">                       tf[j]=<span class="keyword">true</span>;</span><br><span class="line">                       queue.add(j);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="（6）floyd算法"><a href="#（6）floyd算法" class="headerlink" title="（6）floyd算法"></a>（6）floyd算法</h4><p>基于动态规划，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dist[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">210</span>][<span class="number">210</span>],n;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    dist[i][j]=Math.min(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)dist[i][j]=<span class="number">0</span>;<span class="comment">//避免自环</span></span><br><span class="line">                <span class="keyword">else</span> dist[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//接收</span></span><br><span class="line">            dist[x][y]=Math.min(dist[x][y],z);<span class="comment">//避免重边覆盖    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> y=cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(dist[x][y]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="comment">//，有可能更新出一个一个权值较大的路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(dist[x][y]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="（7）prim求最小生成树"><a href="#（7）prim求最小生成树" class="headerlink" title="（7）prim求最小生成树"></a>（7）prim求最小生成树</h4><p>和dijkstra算法差不多，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[N][N],dist[]=<span class="keyword">new</span> <span class="keyword">int</span>[N]，n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录总路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tf[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j])) t=j;</span><br><span class="line">            &#125;</span><br><span class="line">            tf[t]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;dist[t]==INF)<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//此路不通</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)res+=dist[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//更新t到j的距离</span></span><br><span class="line">                dist[j]=Math.min(dist[j],arr[t][j]);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n; j++)</span><br><span class="line">                arr[i][j]=INF;</span><br><span class="line">   <span class="comment">//接收</span></span><br><span class="line">            arr[x][y]=arr[y][x]=Math.min(arr[x][y],z);</span><br></pre></td></tr></table></figure><h4 id="（8）kruskal算法求最小生成树"><a href="#（8）kruskal算法求最小生成树" class="headerlink" title="（8）kruskal算法求最小生成树"></a>（8）kruskal算法求最小生成树</h4><p>1.按权值大小排序，遍历所有边</p><p>2.查看两端是否在树上，不在就连一条边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt;</span>&#123;<span class="comment">//存储边</span></span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x=x;</span><br><span class="line">            <span class="keyword">this</span>.y=y;</span><br><span class="line">            <span class="keyword">this</span>.z=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge e)</span></span>&#123;<span class="comment">//重写比较器</span></span><br><span class="line">            <span class="keyword">return</span> Integer.compare(z,e.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> Edge edge[]=<span class="keyword">new</span> Edge[M];<span class="comment">//类对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],n,m;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//并查集</span></span><br><span class="line">        <span class="keyword">if</span>(p[x]!=x)&#123;</span><br><span class="line">            p[x]=find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;<span class="comment">//主函数</span></span><br><span class="line">        Arrays.sort(edge,<span class="number">0</span>,m);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>，cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//遍历所有边</span></span><br><span class="line">            <span class="keyword">int</span> x=edge[i].x,y=edge[i].y,z=edge[i].z;</span><br><span class="line">            x=find(x),y=find(y);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)&#123;<span class="comment">//不在集合就加入，因为排过序，所以保证了没一条新加入树的边都是最短的</span></span><br><span class="line">                p[x]=y;</span><br><span class="line">                res+=z;<span class="comment">//累加</span></span><br><span class="line">                cnt++;<span class="comment">//记录边数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;n-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//边的数量不对说明不存在最小生成树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//并查集的初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">            edge[i]=<span class="keyword">new</span> Edge(x,y,z);<span class="comment">//存储</span></span><br></pre></td></tr></table></figure><h4 id="（9）-染色法判定二分图"><a href="#（9）-染色法判定二分图" class="headerlink" title="（9） 染色法判定二分图"></a>（9） 染色法判定二分图</h4><p>对某个点进行染色，更新其他点的颜色，没有冲突就是二分图</p><p>二分图没有奇数环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],idx;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> colour[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//邻接表存点</span></span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">get_colour</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//每次一条路染到黑，有冲突就结束</span></span><br><span class="line">        colour[u]=c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(colour[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!get_colour(j,<span class="number">3</span>-c))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(colour[j]==c)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//接收 </span></span><br><span class="line">            add(a,b);<span class="comment">//无向图连两条相反边即可</span></span><br><span class="line">            add(b,a);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//小标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colour[i]==<span class="number">0</span>)&#123;<span class="comment">//没有被染色的就默认染上1</span></span><br><span class="line">            <span class="keyword">if</span>(!get_colour(i,<span class="number">1</span>))&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-二分图最大匹配"><a href="#10-二分图最大匹配" class="headerlink" title="(10)二分图最大匹配"></a>(10)二分图最大匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M=<span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],e[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],ne[]=<span class="keyword">new</span> <span class="keyword">int</span>[M],idx;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> match[]=<span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[M];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//邻接表</span></span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> g)</span></span>&#123;<span class="comment">//找匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[g];i!=-<span class="number">1</span>;i=ne[i])&#123;<span class="comment">//找一个匹配点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(!tf[j])&#123;<span class="comment">//没有在本轮被匹配</span></span><br><span class="line">                tf[j]=<span class="keyword">true</span>;<span class="comment">//标号</span></span><br><span class="line">                <span class="comment">//有可能没被匹配，也可能已经上一轮的其他点匹配，找它的上一个点试试能不能去寻找其他点的匹配，如果找到，则把当前点匹配成功，如果找不到，就继续向下找，如果一个都找不到就返回false;</span></span><br><span class="line">                <span class="keyword">if</span>(match[j]==<span class="number">0</span>||find(match[j]))&#123;</span><br><span class="line">                    match[j]=g;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>)</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">            add(a,b);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;<span class="comment">//遍历其中一个集合的点</span></span><br><span class="line">            Arrays.fill(tf,<span class="keyword">false</span>);<span class="comment">//初始化标记</span></span><br><span class="line">            <span class="keyword">if</span>(find(i))res++;<span class="comment">//找到匹配加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h4 id="1-试除法判定质数"><a href="#1-试除法判定质数" class="headerlink" title="(1)试除法判定质数"></a>(1)试除法判定质数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;<span class="comment">//i*i小于等于n</span></span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2-分解质因数"><a href="#（2-分解质因数" class="headerlink" title="（2)分解质因数"></a>（2)分解质因数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">re_Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot; &quot;</span>+res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)System.out.println(n+<span class="string">&quot; &quot;</span>+<span class="number">1</span>);<span class="comment">//如果你！=1，说明还有一个最大的质数</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-筛子质数"><a href="#3-筛子质数" class="headerlink" title="(3)筛子质数"></a>(3)筛子质数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//一般筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tf[i])primes[++ans]=i;<span class="comment">//把质数存起来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) tf[j]=<span class="keyword">true</span>;<span class="comment">//j=j+i就是要把质数为i的数筛掉，如10=5+5-&gt;15=10+5,注意的是j包括所有数不只是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//埃氏筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!tf[i])&#123;</span><br><span class="line">               primes[++ans]=i;<span class="comment">//</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i) tf[j]=<span class="keyword">true</span>;<span class="comment">//这里的j全是当前质数的倍数，和一般筛法比较快(相当于剪枝)</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tf[i])primes[++ans]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;primes[j]&lt;=n/i;j++)&#123;<span class="comment">//每次都用最小的质数筛掉</span></span><br><span class="line">                   tf[primes[j]*i]=<span class="keyword">true</span>;<span class="comment">//</span></span><br><span class="line">                   <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="（1）试除法求约数"><a href="#（1）试除法求约数" class="headerlink" title="（1）试除法求约数"></a>（1）试除法求约数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_approximate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ap[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">500</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ap[ans++]=i;</span><br><span class="line">            <span class="keyword">if</span>(i!=n/i)ap[ans++]=n/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(ap,<span class="number">0</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）约数个数"><a href="#（2）约数个数" class="headerlink" title="（2）约数个数"></a>（2）约数个数</h4><p>利用组合：如果n=p$_1$$^k$$^1$ p$_2$$^k$$^2$p$_3$$^k$$^3$  那它的约数个数就等于（k1+1)(k2+1)(k3+1),即求质因子的组合个数，其中1相当于1$^0$所以不考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//求质因子及其个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+res);<span class="comment">//对应键值对加上质数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)map.put(n,map.getOrDefault(n,<span class="number">0</span>)+<span class="number">1</span>);   </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> nums: map.values())<span class="comment">//获取键值对的值</span></span><br><span class="line">        ans=(ans*(nums+<span class="number">1</span>))%mod;</span><br></pre></td></tr></table></figure><h4 id="（3）约数之和"><a href="#（3）约数之和" class="headerlink" title="（3）约数之和"></a>（3）约数之和</h4><p>如果n=p$_1$$^k$$^1$ p$_2$$^k$$^2$p$_3$$^k$$^3$, 哪它约数和就为 (p$_1$$^k$$^1$+p$_1$$^k$$^1$$$^-$$$^1$+…..+p$_1$$^0$)  *  (p$_2$$^k$$^2$+p$_2$$^k$$^2$$$^-$$$^1$+…..+p$_2$$^0$)*(p$_3$$^k$$^3$+p$_3$$^k$$^3$$$^-$$$^1$+…..+p$_3$$^0$)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt;entry : map.entrySet())&#123;<span class="comment">//遍历哈希表</span></span><br><span class="line">     <span class="keyword">int</span> key=entry.getKey();</span><br><span class="line">     <span class="keyword">int</span> val=entry.getValue();</span><br><span class="line">     <span class="keyword">long</span> sum=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(val--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         sum=(sum*key+<span class="number">1</span>)%mod;</span><br><span class="line">     &#125;</span><br><span class="line">     ans=(sum*ans)%mod;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="（4）最大公约数"><a href="#（4）最大公约数" class="headerlink" title="（4）最大公约数"></a>（4）最大公约数</h4><p>辗转相除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&gt;<span class="number">0</span>? gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="（1）欧拉函数"><a href="#（1）欧拉函数" class="headerlink" title="（1）欧拉函数"></a>（1）欧拉函数</h4><p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20211211220230.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_Eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) n=n/i;</span><br><span class="line">        sum=sum-sum/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)sum=sum-sum/n;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）筛法求欧拉函数"><a href="#（2）筛法求欧拉函数" class="headerlink" title="（2）筛法求欧拉函数"></a>（2）筛法求欧拉函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">long</span> eulers[]=<span class="keyword">new</span> <span class="keyword">long</span>[N];</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> primes[]=<span class="keyword">new</span> <span class="keyword">int</span>[N],ans;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">boolean</span> tf[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">long</span>  <span class="title">get_Eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       eulers[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!tf[i])&#123;</span><br><span class="line">               primes[ans++]=i;</span><br><span class="line">               eulers[i]=i-<span class="number">1</span>;<span class="comment">//质数的欧拉函数是其本身减一</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;</span><br><span class="line">               tf[primes[j]*i]=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123;<span class="comment">//如果primes[j]是i的最小质数，那么primes[j]*i的欧拉函数就为i的欧拉函数乘上primes[j]，因为欧拉函数只和质数（p）和其本身（N）有关和指数（a）无关；</span></span><br><span class="line">                   eulers[primes[j]*i]=eulers[i]*primes[j];</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;<span class="comment">//如果i和primes[j]互质，那么primes[j]*i的欧拉函数就为i和primes[j]欧拉函数的和；</span></span><br><span class="line">               <span class="keyword">else</span> eulers[primes[j]*i]=eulers[i]*eulers[primes[j]];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           eulers[i]+=eulers[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> eulers[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h4 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h4><p>能快速求出a$^b$%p的值把 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get_Quick</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>)res=res*a%p;<span class="comment">//当二进制数位上为一时</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;<span class="comment">//每次把k最后一位删掉</span></span><br><span class="line">        a=a*a%p;<span class="comment">//每次都跟新a的指数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20211212123800.png"></p><p>其实就是找到一个x  1=b$<em>$x(mod m)   当m为质数时 由费马定理   b$^m$$^-$$^1$(mod m)=1    b$</em>$b$^m$$^-$$^2$(mod m)=1  x=b$^m$$^-$$^2$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b%m==<span class="number">0</span>)System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(get_Qmi(a,m-<span class="number">2</span>,m));</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>裴蜀定理：有一对正整数a,b,那么一定存在整数x，y,使得 ax+ay=gcd(a,b)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x,y;<span class="comment">//java没有变量引用，开全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b%d==<span class="number">0</span>)<span class="comment">//线性同余方程转换为欧几里得算法，当b是最大公约数d的倍数时有解</span></span><br><span class="line">System.out.println(b/d*x%m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h4 id="（1）-高斯消元接解线性方程组"><a href="#（1）-高斯消元接解线性方程组" class="headerlink" title="（1） 高斯消元接解线性方程组"></a>（1） 高斯消元接解线性方程组</h4><h4 id="（2）高斯消元解异或线性方程组"><a href="#（2）高斯消元解异或线性方程组" class="headerlink" title="（2）高斯消元解异或线性方程组"></a>（2）高斯消元解异或线性方程组</h4><h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="（1）Nim游戏"><a href="#（1）Nim游戏" class="headerlink" title="（1）Nim游戏"></a>（1）Nim游戏</h4><h4 id="（2）台阶"><a href="#（2）台阶" class="headerlink" title="（2）台阶"></a>（2）台阶</h4><h4 id="（3）集合"><a href="#（3）集合" class="headerlink" title="（3）集合"></a>（3）集合</h4><h4 id="（4）拆分"><a href="#（4）拆分" class="headerlink" title="（4）拆分"></a>（4）拆分</h4>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
